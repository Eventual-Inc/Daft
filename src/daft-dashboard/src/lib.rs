mod api;
mod dataframe;
#[cfg(feature = "python")]
pub mod python;
mod state;

use std::{future::Future, io::ErrorKind, net::Ipv4Addr};

use axum::Router;
use include_dir::{Dir, include_dir};
#[cfg(feature = "python")]
use pyo3::prelude::*;
use tokio::net::TcpListener;
use tower::ServiceBuilder;
use tower_http::{cors::CorsLayer, services::ServeDir, trace::TraceLayer};

pub const DEFAULT_SERVER_ADDR: Ipv4Addr = Ipv4Addr::LOCALHOST;
pub const DEFAULT_SERVER_PORT: u16 = 3238;
/// Environment variable for the Daft Dashboard URL
/// If provided, connect to the dashboard server at the given URL.
const DAFT_DASHBOARD_URL_ENV: &str = "DAFT_DASHBOARD_URL";

// $DASHBOARD_ASSETS_DIR is generated by the build script
// and contains all the static files for the dashboard.
static ASSETS_DIR: Dir = include_dir!("$DASHBOARD_ASSETS_DIR");

pub async fn make_listener() -> std::io::Result<TcpListener> {
    let mut port = DEFAULT_SERVER_PORT;
    let max_port = port + 100; // Try up to 100 ports after the default

    while port <= max_port {
        match TcpListener::bind((DEFAULT_SERVER_ADDR, port)).await {
            Ok(listener) => {
                return Ok(listener);
            }
            Err(e) if e.kind() == ErrorKind::AddrInUse => {
                port += 1;
            }
            Err(e) => return Err(e),
        }
    }

    Err(std::io::Error::new(
        ErrorKind::AddrInUse,
        format!(
            "No available ports in range {}..={}",
            DEFAULT_SERVER_PORT, max_port
        ),
    ))
}

pub async fn launch_server(
    listener: TcpListener,
    shutdown_fn: impl Future<Output = ()> + Send + 'static,
) {
    // Start an Axum server
    let app = Router::new()
        .merge(api::api_routes())
        .nest_service("/", ServeDir::new(ASSETS_DIR.path()))
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(CorsLayer::very_permissive()),
        );

    axum::serve(listener, app)
        .with_graceful_shutdown(shutdown_fn)
        .await
        .unwrap();
}

#[cfg(feature = "python")]
pub fn register_modules(parent: &Bound<PyModule>) -> PyResult<()> {
    let module = PyModule::new(parent.py(), "dashboard")?;
    module.add("DAFT_DASHBOARD_URL_ENV", DAFT_DASHBOARD_URL_ENV)?;
    module.add_class::<python::PyConnectionHandle>()?;
    module.add_function(wrap_pyfunction!(python::connect, &module)?)?;
    parent.add_submodule(&module)?;

    Ok(())
}
