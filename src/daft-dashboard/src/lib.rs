#[cfg(feature = "python")]
pub mod python;
mod response;

use std::{collections::HashMap, io::Cursor, net::Ipv4Addr, sync::Arc};

use http_body_util::{combinators::BoxBody, BodyExt, Full};
use hyper::{
    body::{Bytes, Incoming},
    server::conn::http1,
    service::service_fn,
    Method, Request, Response, StatusCode,
};
use hyper_util::rt::TokioIo;
use include_dir::{include_dir, Dir};
use parking_lot::RwLock;
#[cfg(feature = "python")]
use pyo3::prelude::*;
use serde::{Deserialize, Serialize};
use tokio::{net::TcpStream, spawn};
use uuid::Uuid;

type StrRef = Arc<str>;
type Req<T = Incoming> = Request<T>;
type Res = Response<BoxBody<Bytes, std::io::Error>>;
type ServerResult<T> = Result<T, (StatusCode, anyhow::Error)>;

pub const SERVER_ADDR: Ipv4Addr = Ipv4Addr::LOCALHOST;
pub const SERVER_PORT: u16 = 3238;

// $DASHBOARD_ASSETS_DIR is generated by the build script
// and contains all the static files for the dashboard.
static ASSETS_DIR: Dir = include_dir!("$DASHBOARD_ASSETS_DIR");

trait ResultExt<T, E: Into<anyhow::Error>>: Sized {
    fn with_status_code(self, status_code: StatusCode) -> ServerResult<T>;
    fn with_internal_error(self) -> ServerResult<T>;
}

impl<T, E: Into<anyhow::Error>> ResultExt<T, E> for Result<T, E> {
    fn with_status_code(self, status_code: StatusCode) -> ServerResult<T> {
        self.map_err(|err| (status_code, err.into()))
    }

    fn with_internal_error(self) -> ServerResult<T> {
        self.with_status_code(StatusCode::INTERNAL_SERVER_ERROR)
    }
}

#[derive(Deserialize, Serialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "snake_case", deny_unknown_fields)]
struct QueryInformation {
    id: StrRef,
    unoptimized_plan: Option<StrRef>,
    optimized_plan: Option<StrRef>,
    plan_time_start: StrRef,
    plan_time_end: StrRef,
    logs: Option<StrRef>,
    run_id: Option<StrRef>,
}

// DataFrame display structures
#[derive(Debug, Clone)]
struct DataFrameInfo {
    #[allow(dead_code)]
    id: String,
    record_batch: daft_recordbatch::RecordBatch,
}

#[allow(dead_code)]
#[derive(Deserialize)]
struct CellRequest {
    row: usize,
    col: usize,
}

#[derive(Serialize)]
struct CellResponse {
    #[serde(rename = "type")]
    cell_type: String,
    value: String,
    data_type: String,
}

#[derive(Clone, Debug)]
struct DashboardState {
    queries: Arc<RwLock<Vec<QueryInformation>>>,
    dataframes: Arc<RwLock<HashMap<String, DataFrameInfo>>>,
}

impl DashboardState {
    fn new() -> Self {
        Self {
            queries: Arc::default(),
            dataframes: Arc::default(),
        }
    }

    fn queries(&self) -> Vec<QueryInformation> {
        // TODO: The cloning here is a little ugly.
        // The reason the list is cloned is because returning a `&[QueryInformation]` will not work due to borrowing rules.
        self.queries.read().clone()
    }

    fn add_query(&self, query_information: QueryInformation) {
        self.queries.write().push(query_information);
    }

    fn register_dataframe(&self, record_batch: daft_recordbatch::RecordBatch) -> String {
        let id = Uuid::new_v4().to_string();
        let info = DataFrameInfo {
            id: id.clone(),
            record_batch,
        };
        self.dataframes.write().insert(id.clone(), info);
        id
    }

    fn get_dataframe(&self, id: &str) -> Option<DataFrameInfo> {
        self.dataframes.read().get(id).cloned()
    }
}

async fn deserialize<T: for<'de> Deserialize<'de>>(req: Req) -> ServerResult<Req<T>> {
    let (parts, body) = req.into_parts();
    let bytes = body.collect().await.with_internal_error()?.to_bytes();
    let mut cursor = Cursor::new(bytes);
    let body = serde_json::from_reader(&mut cursor).with_status_code(StatusCode::BAD_REQUEST)?;

    Ok(Request::from_parts(parts, body))
}

fn parse_query_params(query: Option<&str>) -> HashMap<String, String> {
    query
        .unwrap_or("")
        .split('&')
        .filter_map(|param| {
            let mut parts = param.splitn(2, '=');
            match (parts.next(), parts.next()) {
                (Some(key), Some(value)) => Some((key.to_string(), value.to_string())),
                _ => None,
            }
        })
        .collect()
}

async fn serve_cell_content(
    dataframe_id: &str,
    params: HashMap<String, String>,
    state: &DashboardState,
) -> ServerResult<Res> {
    let row: usize = params
        .get("row")
        .and_then(|r| r.parse().ok())
        .ok_or_else(|| {
            (
                StatusCode::BAD_REQUEST,
                anyhow::anyhow!("Invalid row parameter"),
            )
        })?;

    let col: usize = params
        .get("col")
        .and_then(|c| c.parse().ok())
        .ok_or_else(|| {
            (
                StatusCode::BAD_REQUEST,
                anyhow::anyhow!("Invalid col parameter"),
            )
        })?;

    let dataframe = state.get_dataframe(dataframe_id).ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            anyhow::anyhow!("DataFrame not found"),
        )
    })?;

    if row >= dataframe.record_batch.len() || col >= dataframe.record_batch.num_columns() {
        return Err((
            StatusCode::BAD_REQUEST,
            anyhow::anyhow!("Row or column index out of bounds"),
        ));
    }

    let column = dataframe.record_batch.get_column(col);
    let cell_html = daft_recordbatch::html_value(column, row, false);

    let response = CellResponse {
        cell_type: "html".to_string(),
        value: cell_html,
        data_type: format!("{:?}", column.data_type()),
    };

    Ok(response::with_body(StatusCode::OK, response))
}

fn generate_interactive_html(
    data_frame: &DataFrameInfo,
    df_id: &str,
    host: &str,
    port: u16,
) -> String {
    // Start with the basic table HTML from repr_html
    let table_html = data_frame.record_batch.repr_html();
    // Build the complete interactive HTML
    let mut html = vec!["<div>".to_string()];

    // Add modal HTML structure
    html.push(
        r#"
        <div id="cell-modal" class="modal" style="display: none;">
            <div class="modal-overlay"></div>
            <div class="modal-content">
                <div class="modal-header">
                    <h3 id="modal-title">Cell Content</h3>
                    <button class="modal-close" id="modal-close">&times;</button>
                </div>
                <div class="modal-body" id="modal-body">
                    <div class="loading-spinner" id="modal-loading">Loading...</div>
                    <div id="modal-content-area"></div>
                </div>
            </div>
        </div>
        "#
        .to_string(),
    );

    // Add the table HTML
    html.push(table_html);

    // Add CSS and JavaScript
    html.push(format!(
        r#"
        <style>
        .dataframe {{
            border-collapse: collapse;
        }}
        .dataframe td {{
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s;
        }}


        .dataframe td.loading {{
            background-color: #e3f2fd;
            opacity: 0.7;
        }}
        .cell-content {{
            max-width: 192px;
            max-height: 64px;
            overflow: auto;
        }}

        /* Modal styles */
        .modal {{
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }}

        .modal-overlay {{
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            cursor: pointer;
        }}

        .modal-content {{
            position: relative;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 80vw;
            max-height: 80vh;
            min-width: 400px;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            z-index: 1001;
        }}

        .modal-header {{
            padding: 16px 20px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #f8f9fa;
            border-radius: 8px 8px 0 0;
        }}

        .modal-header h3 {{
            margin: 0;
            font-size: 18px;
            color: #333;
        }}

        .modal-close {{
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background-color 0.2s;
        }}

        .modal-close:hover {{
            background-color: #e0e0e0;
            color: #333;
        }}

        .modal-body {{
            padding: 20px;
            overflow: auto;
            flex: 1;
            position: relative;
        }}

        .loading-spinner {{
            text-align: center;
            padding: 40px;
            color: #666;
            font-style: italic;
        }}

        #modal-content-area {{
            word-wrap: break-word;
            overflow-wrap: break-word;
        }}

        /* Hide scrollbars for webkit browsers while keeping scroll functionality */
        .modal-body::-webkit-scrollbar {{
            width: 8px;
        }}

        .modal-body::-webkit-scrollbar-track {{
            background: #f1f1f1;
            border-radius: 4px;
        }}

        .modal-body::-webkit-scrollbar-thumb {{
            background: #c1c1c1;
            border-radius: 4px;
        }}

        .modal-body::-webkit-scrollbar-thumb:hover {{
            background: #a8a8a8;
        }}
        </style>
        <script>
        (function() {{
            console.log('Dashboard script starting...');
            const serverUrl = 'http://{}:{}';
            const dfId = '{}';
            console.log('Server URL:', serverUrl, 'DF ID:', dfId);

            function showModal(row, col) {{
                console.log('showModal called with row:', row, 'col:', col);
                const modal = document.getElementById('cell-modal');
                const modalTitle = document.getElementById('modal-title');
                const modalLoading = document.getElementById('modal-loading');
                const modalContent = document.getElementById('modal-content-area');

                modalTitle.textContent = `Cell Content (Row ${{row + 1}}, Column ${{col + 1}})`;
                modalLoading.style.display = 'block';
                modalContent.style.display = 'none';
                modal.style.display = 'flex';

                const url = `${{serverUrl}}/api/dataframes/${{dfId}}/cell?row=${{row}}&col=${{col}}`;
                console.log('Fetching from:', url);

                fetch(url)
                    .then(response => {{
                        console.log('Response status:', response.status);
                        return response.json();
                    }})
                    .then(data => {{
                        console.log('Response data:', data);
                        modalLoading.style.display = 'none';
                        modalContent.innerHTML = data.value;
                        modalContent.style.display = 'block';
                    }})
                    .catch(err => {{
                        console.error('Fetch error:', err);
                        modalLoading.style.display = 'none';
                        modalContent.innerHTML = 'Error loading content: ' + err.message;
                        modalContent.style.display = 'block';
                    }});
            }}

            function hideModal() {{
                console.log('hideModal called');
                document.getElementById('cell-modal').style.display = 'none';
            }}

            // Find and add click handlers to cells
            console.log('Looking for clickable cells...');
            const cells = document.querySelectorAll('.dataframe td');
            console.log('Found', cells.length, 'cells');

            // Add click handlers to each cell
            cells.forEach((cell) => {{
                // Skip cells that contain "..." (ellipsis row)
                if (cell.textContent.trim() === '...') {{
                    return;
                }}

                // Get row and column from data attributes
                const row = parseInt(cell.getAttribute('data-row'));
                const col = parseInt(cell.getAttribute('data-col'));

                cell.onclick = function() {{
                    console.log('Cell clicked! row:', row, 'col:', col);
                    showModal(row, col);
                }};
                // Add visual feedback
                cell.style.cursor = 'pointer';
                cell.title = 'Click to view full content';
            }});

            // Modal close handlers
            const modalClose = document.getElementById('modal-close');
            const modalOverlay = document.querySelector('.modal-overlay');

            if (modalClose) {{
                modalClose.onclick = hideModal;
                console.log('Modal close button handler added');
            }} else {{
                console.log('Modal close button not found');
            }}

            if (modalOverlay) {{
                modalOverlay.onclick = hideModal;
                console.log('Modal overlay handler added');
            }} else {{
                console.log('Modal overlay not found');
            }}

            document.addEventListener('keydown', function(e) {{
                if (e.key === 'Escape') {{
                    console.log('Escape key pressed');
                    hideModal();
                }}
            }});

            console.log('Dashboard script setup complete');
        }})();
        </script>
        "#,
        host, port, df_id
    ));

    html.push("</div>".to_string()); // Close the wrapper div

    html.join("")
}

async fn http_server_application(req: Req, state: DashboardState) -> ServerResult<Res> {
    let request_path = req.uri().path();

    let paths = request_path
        .split('/')
        .filter(|segment| !segment.is_empty())
        .collect::<Vec<_>>();

    Ok(match (req.method(), paths.as_slice()) {
        // Handle CORS preflight requests
        (&Method::OPTIONS, _) => response::empty(StatusCode::OK),
        (&Method::POST, ["api", "queries"]) => {
            let req = deserialize::<QueryInformation>(req).await?;
            state.add_query(req.into_body());
            response::empty(StatusCode::OK)
        }
        (&Method::GET, ["api", "queries"]) => {
            let query_informations = state.queries();

            response::with_body(StatusCode::OK, query_informations.as_slice())
        }
        (&Method::GET, ["api", "dataframes", dataframe_id, "cell"]) => {
            let params = parse_query_params(req.uri().query());
            serve_cell_content(dataframe_id, params, &state).await?
        }
        (_, ["api", ..]) => response::empty(StatusCode::NOT_FOUND),

        // All other paths (that don't start with "api") will be treated as web-server requests.
        (&Method::GET, _) => {
            let request_path = req.uri().path();
            let path = request_path.trim_start_matches('/');

            let path = if path.is_empty() { "index.html" } else { path };

            // Try to get the file directly
            let file = ASSETS_DIR.get_file(path).or_else(|| {
                // If not found and doesn't end with .html, try with .html extension
                if !std::path::Path::new(path)
                    .extension()
                    .is_some_and(|ext| ext.eq_ignore_ascii_case("html"))
                {
                    ASSETS_DIR.get_file(format!("{}.html", path))
                } else {
                    None
                }
            });

            match file {
                Some(file) => {
                    let content_type = match file.path().extension().and_then(|ext| ext.to_str()) {
                        Some("html") => "text/html",
                        Some("css") => "text/css",
                        Some("js") => "application/javascript",
                        Some("png") => "image/png",
                        Some("jpg") | Some("jpeg") => "image/jpeg",
                        _ => "application/octet-stream",
                    };

                    let bytes = Bytes::copy_from_slice(file.contents());

                    Response::builder()
                        .status(StatusCode::OK)
                        .header("Content-Type", content_type)
                        .header("Access-Control-Allow-Origin", "*")
                        .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                        .header("Access-Control-Allow-Headers", "Content-Type")
                        .body(
                            Full::new(bytes)
                                .map_err(|infallible| match infallible {})
                                .boxed(),
                        )
                        .unwrap()
                }
                None => response::empty(StatusCode::NOT_FOUND),
            }
        }

        _ => response::empty(StatusCode::NOT_FOUND),
    })
}

fn handle_stream(stream: TcpStream, state: DashboardState) {
    let io = TokioIo::new(stream);
    spawn(async move {
        http1::Builder::new()
            .serve_connection(
                io,
                service_fn(move |request| {
                    let state = state.clone();
                    async move {
                        Ok::<_, std::convert::Infallible>(
                            match http_server_application(request, state).await {
                                Ok(response) => response,
                                Err((status_code, error)) => {
                                    response::with_body(status_code, error.to_string())
                                }
                            },
                        )
                    }
                }),
            )
            .await
            .unwrap();
    });
}

#[cfg(feature = "python")]
pub fn register_modules(parent: &Bound<PyModule>) -> PyResult<()> {
    const DAFT_DASHBOARD_ENV_ENABLED: &str = "DAFT_DASHBOARD_ENABLED";
    const DAFT_DASHBOARD_ENV_NAME: &str = "DAFT_DASHBOARD";
    const DAFT_DASHBOARD_URL: &str = "http://localhost:3238";
    const DAFT_DASHBOARD_QUERIES_URL: &str = "http://localhost:3238/api/queries";

    let module = PyModule::new(parent.py(), "dashboard")?;
    module.add_wrapped(wrap_pyfunction!(python::launch))?;
    module.add_wrapped(wrap_pyfunction!(python::register_dataframe_for_display))?;
    module.add_wrapped(wrap_pyfunction!(python::generate_interactive_html))?;
    // module.add_wrapped(wrap_pyfunction!(python::shutdown))?;
    // module.add_wrapped(wrap_pyfunction!(python::cli))?;
    module.add("DAFT_DASHBOARD_ENV_NAME", DAFT_DASHBOARD_ENV_NAME)?;
    module.add("DAFT_DASHBOARD_URL", DAFT_DASHBOARD_URL)?;
    module.add("DAFT_DASHBOARD_QUERIES_URL", DAFT_DASHBOARD_QUERIES_URL)?;
    module.add("DAFT_DASHBOARD_ENV_ENABLED", DAFT_DASHBOARD_ENV_ENABLED)?;
    parent.add_submodule(&module)?;

    Ok(())
}
